from __future__ import annotations

import argparse
import json
import subprocess
from dataclasses import dataclass
from pathlib import Path
from typing import Any


@dataclass(frozen=True)
class Metrics:
    stereo_rms_px: float
    baseline_abs_error_px_at_mean_depth: float
    tri_rms_rel_depth_percent: float
    rayfield_baseline_abs_error_px_at_mean_depth: float
    rayfield_tri_rms_rel_depth_percent: float


def run(cmd: list[str]) -> None:
    res = subprocess.run(cmd, text=True, capture_output=True)
    if res.returncode != 0:
        msg = ["Command failed:", "  " + " ".join(cmd)]
        if res.stdout:
            msg.append("--- stdout ---")
            msg.append(res.stdout)
        if res.stderr:
            msg.append("--- stderr ---")
            msg.append(res.stderr)
        raise RuntimeError("\n".join(msg))


def load_json(path: Path) -> dict[str, Any]:
    return json.loads(path.read_text(encoding="utf-8"))


def extract_metrics(report: dict[str, Any]) -> Metrics:
    ocv = report["opencv_pinhole_calib"]
    depth_mean = float(report["depth_mm"]["mean"])
    tri_rf_mm = float(report["rayfield3d_ba"]["triangulation_error_mm_aligned_similarity"]["rms"])
    tri_rf_rel = 100.0 * tri_rf_mm / (depth_mean + 1e-12)
    return Metrics(
        stereo_rms_px=float(ocv["stereo_rms_px"]),
        baseline_abs_error_px_at_mean_depth=float(ocv["rig"]["baseline_abs_error_px_at_mean_depth"]),
        tri_rms_rel_depth_percent=float(ocv["triangulation_error_rel_depth_percent"]["rms"]),
        rayfield_baseline_abs_error_px_at_mean_depth=float(report["rig"]["baseline_abs_error_px_at_mean_depth"]),
        rayfield_tri_rms_rel_depth_percent=float(tri_rf_rel),
    )


def _fmt(x: float, nd: int = 3) -> str:
    return f"{float(x):.{nd}f}"


def write_latex_table(*, out_path: Path, data: dict[str, dict[int, Metrics]]) -> None:
    lines: list[str] = []
    pretty = {
        "png_lossless": "PNG (lossless)",
        "webp_q70": "WebP (q70)",
        "webp_q80": "WebP (q80)",
        "webp_q90": "WebP (q90)",
        "webp_q95": "WebP (q95)",
        "jpeg_q80": "JPEG (q80)",
        "jpeg_q90": "JPEG (q90)",
        "jpeg_q95": "JPEG (q95)",
        "jpeg_q98": "JPEG (q98)",
    }
    lines.append("% Auto-generated by paper/experiments/sweep_num_frames.py")
    lines.append("\\begin{table}[t]")
    lines.append("\\centering")
    lines.append("\\scriptsize")
    lines.append("\\setlength{\\tabcolsep}{4pt}")
    lines.append("\\begin{tabular}{l c c c c c}")
    lines.append("\\toprule")
    lines.append(
        "Codec & \\#frames & Stereo RMS (px) & Baseline err (px @ $\\bar Z$) & Tri RMS (\\%$\\bar Z$) & "
        + "Ray-field Tri RMS (\\%$\\bar Z$)\\\\"
    )
    lines.append("\\midrule")
    for codec, by_frames in data.items():
        codec_label = pretty.get(codec, codec)
        lines.append(f"\\multicolumn{{6}}{{l}}{{\\textbf{{{codec_label}}}}}\\\\")
        for n_frames in sorted(by_frames):
            m = by_frames[n_frames]
            lines.append(
                f"\\quad & {n_frames:d} & {_fmt(m.stereo_rms_px)} & {_fmt(m.baseline_abs_error_px_at_mean_depth)} & "
                f"{_fmt(m.tri_rms_rel_depth_percent)} & {_fmt(m.rayfield_tri_rms_rel_depth_percent)}\\\\"
            )
        lines.append("\\addlinespace")
    lines.append("\\bottomrule")
    lines.append("\\end{tabular}")
    lines.append(
        "\\caption{Sensitivity to the number of calibration frames on two representative codec settings "
        "(planar refinement enabled). The released training split used in this paper contains 8 frames; "
        "we sweep within this available range. We report pinhole stereo metrics (Stereo RMS, baseline error at mean "
        "depth, and depth-normalized triangulation RMS) alongside the compact ray-based backend triangulation "
        "stability.}"
    )
    lines.append("\\label{tab:num_frames_sweep}")
    lines.append("\\end{table}")
    lines.append("")
    out_path.write_text("\n".join(lines), encoding="utf-8")


def main(argv: list[str] | None = None) -> int:
    ap = argparse.ArgumentParser(description="Sweep the number of calibration frames (pose count) on two codecs.")
    ap.add_argument("--root", type=Path, default=Path("dataset/compression_sweep"))
    ap.add_argument("--codecs", type=str, default="png_lossless,webp_q70")
    ap.add_argument("--split", default="train")
    ap.add_argument("--scene", default="scene_0000")
    # The released compression sweep uses 8 training frames (scene_0000/train) and reports results in a low-data
    # regime (default: 5 frames). We sweep within the available range by default.
    ap.add_argument("--frames", type=str, default="2,5,8")
    ap.add_argument("--max-points-per-frame", type=int, default=200)
    ap.add_argument("--outer-iters", type=int, default=3)
    ap.add_argument("--nmax", type=int, default=10)
    ap.add_argument("--tps-lam", type=float, default=10.0)
    ap.add_argument("--tps-huber", type=float, default=3.0)
    ap.add_argument("--tps-iters", type=int, default=3)
    ap.add_argument("--py", type=str, default=".venv/bin/python")
    ap.add_argument("--cal-script", type=Path, default=Path("paper/experiments/calibrate_central_rayfield3d_from_images.py"))
    ap.add_argument("--out-dir", type=Path, default=Path("paper/tables/num_frames_sweep"))
    ap.add_argument("--out-tex", type=Path, default=Path("paper/tables/num_frames_sweep.tex"))
    args = ap.parse_args(argv)

    codecs = [c.strip() for c in args.codecs.split(",") if c.strip()]
    frames_list = [int(x) for x in args.frames.split(",") if x.strip()]

    args.out_dir.mkdir(parents=True, exist_ok=True)

    data: dict[str, dict[int, Metrics]] = {}
    for codec in codecs:
        data[codec] = {}
        for n_frames in frames_list:
            # Reuse existing 5-frame results from the main compression sweep if available.
            if n_frames == 5:
                candidate = Path("paper/tables/compression_compare") / f"{codec}.rayfield2d.json"
                report_path = candidate if candidate.exists() else args.out_dir / f"{codec}.frames{n_frames}.rayfield2d.json"
            else:
                report_path = args.out_dir / f"{codec}.frames{n_frames}.rayfield2d.json"

            if not report_path.exists():
                run(
                    [
                        args.py,
                        str(args.cal_script),
                        str(args.root / codec),
                        "--split",
                        str(args.split),
                        "--scene",
                        str(args.scene),
                        "--method2d",
                        "rayfield_tps_robust",
                        "--max-frames",
                        str(int(n_frames)),
                        "--max-points-per-frame",
                        str(int(args.max_points_per_frame)),
                        "--outer-iters",
                        str(int(args.outer_iters)),
                        "--nmax",
                        str(int(args.nmax)),
                        "--tps-lam",
                        str(float(args.tps_lam)),
                        "--tps-huber",
                        str(float(args.tps_huber)),
                        "--tps-iters",
                        str(int(args.tps_iters)),
                        "--out",
                        str(report_path),
                    ]
                )

            report = load_json(report_path)
            data[codec][int(n_frames)] = extract_metrics(report)

    write_latex_table(out_path=args.out_tex, data=data)
    print(f"Wrote {args.out_tex}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
